[{"title":"JavaScript 之手撕 new","date":"2021-12-25T07:00:37.000Z","url":"/2021/12/25/JavaScript-%E4%B9%8B%E6%89%8B%E6%92%95-new/","tags":[["new","/tags/new/"]],"categories":[["undefined",""]],"content":"前言什么是 new 呢？ new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。 光看定义还是有几分晦涩的，直接看一个具体的例子，来了解一下 JavaScript 中的 new 实现的功能。 举个例子 通过上面这个例子，我们可以发现 xiaobao 可以： 访问到构造函数 Thin_User 中的属性 访问到 Thin_User.prototype 中的属性 描述的更直白一点， new 做了这几件事： 创建了一个空对象，对象的 __ proto __ -&gt; Thin_User.prototype 执行构造函数，并将 this 指向新对象 返回新对象 补充说明由于 new 是关键字，我们无法像模拟数组高阶方法一样覆盖，因此我们写一个函数 createObject ，来模拟 new 的效果。使用具体如下： 初步模拟根据上面的分析，**createObject** 编写大致步骤为： 创建了一个新对象 obj 设置 obj.__ proto __ -&gt; constructor.prototype (但 JavaScript 不推荐直接修改 __ proto__ 属性，提供了 setPrototypeOf 方法来专门修改原型) 使用 constructor.call/apply(obj,…) ,将属性添加到 obj 上 返回 obj 返回值效果众所周知，函数是有返回值的，那构造函数如果有返回值，最终执行 new 后返回的结果是什么样的？ 返回值为基本类型假设构造函数返回值为一个基本类型，我们来看一下最后的返回结果： 最终的返回结果好像没有受到任何干扰，难道构造函数不会对返回值进行处理吗？ 不急，我们来接着测试一下返回值为对象的情况。 当执行 eatToMuch 时，控制台直接报错，没有当前函数，所以答应了 xiaobao 对象： 发现 xiaobao 对象的 age 发生了改变，而且增加了 fat 属性，正好与构造函数的返回值一样。看完这两个例子，基本可以理清构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象。 最终模拟"},{"title":"JavaScript 预编译","date":"2021-12-20T06:09:53.000Z","url":"/2021/12/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","tags":[["JavaScript","/tags/JavaScript/"],["预编译","/tags/%E9%A2%84%E7%BC%96%E8%AF%91/"]],"categories":[["undefined",""]],"content":"JavaScript 从预编译到执行的过程，大致可以分为四步： 词法分析 语法分析：检查代码是否存在错误，若有错误，引擎会抛出语法错误。同时会构建一颗抽象语法树(AST) 预编译 解释执行 预编译 JavaScript 是解释性语言，也就是说，编译一行，执行一行，但是 JS 并非上来就进入编译环节，它在编译之前存在预编译过程。 JS 中预编译一般有两种：全局的预编译和函数的预编译，分别发生在 script 内代码执行前和函数执行前。 函数预编译 首先来看一个例子： 就以上例子中 a 为例，有形参 a ，变量 a ，函数 a ，那 test 函数执行的时候，此时的 a 到底是什么呢？ 输出结果： 要想弄明白最终的输出结果，就不得不好好学习一下预编译的详细过程。 在预编译学习中，经常听到的一句话：函数声明整体提升，变量声明提升。 这句话可以解决大多数场景下的预编译面试题，但光凭这句话是无法吃透预编译的，因此接下来我们来一起捋一下函数预编译的详细流程。 函数预编译四步曲 预编译开始，会建立 AO(Activation Object) 对象 找形参和变量声明，使其作为 AO 的属性名，值赋予 undefined 实参和形参相统一(将实参值赋值为给形参) 找函数声明，函数名作为 AO 属性名，值赋予函数体 案例分析学习了函数的预编译过程，就可以回头细细的品味一下上面的案例： 先建立 AO ，并找形参和变量声明，值赋予 undefined 形参实参相统一 找函数声明，值赋予函数体 预编译过程结束，挨着分析一下 console 的打印结果： 全局预编译 全局中不存在形参和实参，所以全局预编译只需处理变量声明和函数声明。 全局预编译 生成 GO(Global Object) 找变量声明，由于全局变量默认挂载在 window 之上，若 window 当前已存在当前属性，忽略当前操作，若没有，变量作为属性名，值赋予 undefined。 找函数声明，函数与变量类似，先去 window 上查看，不存在，函数作为函数名，值作为函数体。 案例分析将函数预编译案例稍微修改，如下： 生成 GO ，变量提升，函数提升，得到 GO 如下： 因此第一个 a 的值为 undefined ，随后 a 赋值为 1 ，所以第二个 a 的值为 1。 输出结果： test 中定义了变量 a，因此打印的 a 为 自身 AO 中的值。如果 test 中没有定义 a，就会沿着作用域链，到 GO 中 查找 a。 "}]