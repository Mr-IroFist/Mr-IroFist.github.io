[{"title":"slot 插槽","date":"2022-01-23T03:44:04.000Z","url":"/2022/01/23/slot-%E6%8F%92%E6%A7%BD/","tags":[["插槽","/tags/%E6%8F%92%E6%A7%BD/"]],"categories":[["undefined",""]],"content":"用户解决在一个组件里面需要多次使用同一个组件但是内容不一样的问题。 1. 普通插槽 2. 具名插槽有时候我们需要多个插槽 对于这样的情况， &lt; slot &gt; 元素有一个特殊的 attribute： name。这个 attribute 可以用来定义额外的插槽： 一个不带 name 的 &lt; slot &gt; 出口会带有隐含的名字 ‘default’。在向具名插槽提供内容的时候，我们可以在一个 &lt; template &gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称： 现在 &lt; template &gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 &lt; template &gt; 中的内容都会被视为默认插槽的内容。 注意 v-slot 只能添加在 &lt; template &gt; 上，这一点和已经废弃的 slot attribute 不同。 v-slot: 可以简写成 # 3. 插槽的后备内容有时候为一个插槽设置具体的后备(也就是默认)内容是很有用的，它只会在没有提供内容的时候被渲染。 4. 作用域插槽有时候让插槽内容能够访问子组件中才有的数据是很有用的。 绑定在 &lt; slot &gt; 元素上的 attribute 被称为 插槽 prop 。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字。 在这个例子中，我们选择将包含所有插槽 prop 的对象命名 slotProps，但你也可以使用任意你喜欢的名字"},{"title":"Prop 组件复用","date":"2022-01-21T05:43:09.000Z","url":"/2022/01/21/Prop-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/","tags":[["prop","/tags/prop/"]],"categories":[["undefined",""]],"content":"用来实现组件复用，就是子组件在父组件中出现的时候，需要展示的内容，可以让父组件提供。 Prop 的大小写HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelClase(驼峰命名法) 的 prop 名需要使用其等价的 kebba-case (短横线分隔命名) 来命名。 1.实现 Prop① 在组件内传递相应的数据给子组件，直接在子组件的标签上当作属性传递数据，属性名可以自定义，属性值是传递的真正数据。② 子组件获取父组件传递的数据展示，需要在子组件的 script 内导出对象内使用 props 属性接收。 ③ Prop 的验证(类型检查)我们可以为组件的 prop 指定验证要求，例如你知道这些类型。如果有一个需求没有被满足，则 vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。 为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。 2. 单项数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难理解， 额外的，每次父组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。"},{"title":"Vue 简介","date":"2022-01-20T02:30:16.000Z","url":"/2022/01/20/Vue-%E7%AE%80%E4%BB%8B/","tags":[["Vue","/tags/Vue/"]],"categories":[["undefined",""]],"content":"Vue 是一套用于构建用户界面的 渐进式框架。与其他大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于第三方库或即有项目整合。另一方面，当与 现代化的工具链 以及 支持类库 结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 1.Vue 属于单页面应用(SPA)2.单页面应用和多页面应用的优缺点 单页面应用 (single page web application, SPA)只有一个主页面的应用，浏览器一开始要加载所有必须的 html、js、css。所有的页面内容都包含在这个所谓的主页面中，有 JavaScript 来控制。但写的时候还是会分开写(页面片段)，然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用与 PC 端。 优点 ： ① 用户操作体验好，用户不用刷新页面，整个交互过程都是通过 Ajax 来操作。 ② 适合前后端分离开发，服务端提供 http 接口，前端请求 http 接口获取数据，使用 JavaScript 进行客户端渲染。 ③ 页面效果比较酷炫(比如切换页面时的专场动画) 缺点 ： ① 首页加载慢，单页面应用会将 js、css 打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户的体验感会受到影响。 ② SEO 不太友好，SEO(Search Engine Optimization) 为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎排名的方法。目前各家搜索引擎对 JavaScript 支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。 ③ 导航不可用，如果一定要导航需要自行实现前进、后退。(由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理) ④ 页面的复杂度提高很多 3.既然单页面应用有这些缺点，为什么还要使用 VueVue 提供了一些其他技术来解决这些缺点，比如说服务器端渲染技术 (SSR)，通过这些技术可以完美解决这些缺点。解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。 4.前端模块化的好处① 降低复杂度② 降低耦合性什么是耦合性？在编程里面，是指一个程序模块与其他的联系。如果存在联系，就叫做耦合，我们知道总会有必要的耦合，因此解耦是指把这些联系减少到必要的联系即可。所谓的”高聚合、低耦合”就是指这个道理。通过减少代码的耦合性最明确的好处就是有利于代码的维护，可以让分工更加明确，修改代码需要设计的模块也会减少。对于效率能有很大的提高。 耦合性过高的后果 ——- 牵一发而动全身 ③ 部署方便"},{"title":"JavaScript 使用小技巧","date":"2022-01-19T10:56:38.000Z","url":"/2022/01/19/JavaScript-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","categories":[["undefined",""]],"content":"一、解构小技巧平常我们需要用到一个嵌套多层的对象中的某些属性，会将其解构出来使用 在这种情况下，你把 name 和 age 从 part1 里解构出来了以后，你就无法使用变量 obj 中的 part1 属性了，如： 其实可以进行多次解构，如： 二、数字分隔符有时候你会在文件中定义一个数字常量 可以使用数字分隔符 这样写是没有问题的，而且数字分隔开之后也更直观 三、try…catch…finally 谁更厉害？在普通函数中， return 一般会提前结束函数的执行 而在 try…catch…finally 中， return 就不会提前结束执行 四、获取当前调用栈 new Error().stack 这样就能随时获取到当前代码执行的调用栈信息，也可以说是一种调试代码的方法 五、一行代码生成随机字符串 这样就获得了一个 10位数的随机字符串，先是 Math.random() 生成了 [0, 1) 的数，也就是 0.123123、 0.876567 之类的数，然后调用 number 的 toString 方法将其转换成 36 进制的，按照 MDN 的说法，36 进制的转换应该是包含了字母 a ~ z 和 数字 0 ~ 9 的，因为这样生成的是 0.2k2hhfu7fg 类似这样的，所以要截取一下小数部分，即从索引 2 开始截取 10 个 字符就是我们想要的随机字符串了。 六、最快获取 dom 的方法HTML 中带有 id 属性的元素，都会被全局的 ID 同名变量所引用 原本获取 dom 是这样的 现在可以这样 "},{"title":"JavaScript 静态作用域与动态作用域","date":"2022-01-18T06:33:51.000Z","url":"/2022/01/18/JavaScript-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/","tags":[["作用域","/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"]],"categories":[["undefined",""]],"content":"概述在文章开始前，先学习几个概念： 作用域：《你不知道的js》中指出，作用域是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。简单来说，作用域规定了如何查找变量。 静态作用域：又称词法作用域，是指作用域在词法阶段就被确定了，不会改变。 动态作用域：函数的作用域在函数调用时才决定的。 静态作用域与动态作用域JavaScript 采用的是词法作用域，函数定义的位置就决定了函数的作用域。 具体看一个例子： 最终的结果是 1 ，说明 test 打印的是全局下的 val , 这也印证了 JavaScript 使用了静态作用域。 在学习词法作用域之前，已经学习了作用域链和预编译过程，虽然有几分本末倒置，但是对词法的理解还是有一定帮助的。 静态作用域执行过程当函数执行 test 函数时，先从内部的 AO 对象查找是否有 val 对象，如果没有，沿着作用域链往上查找，上层为全局 GO ，所以结果打印 1 。 动态作用域执行过程但如果 JavaScript 采用动态作用域，执行 test 函数，从函数内部查询 val 变量，如果没有，就调用函数的作用域，即 bar 函数的作用域，成功查询到 val = 2 。 思考题 很明显，两个都打印 local scope ,JavaScript 采用词法作用域，上述两个函数都定义在 checkscope 中，所以当 f() 函数执行时，首先查询自身作用域是否有 scope 变量，如果没有，它们的上级作用域都是 checkscope ，所以输出 local scope 。 对此 《JavaScript权威指南》 解释到： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f() ,这种绑定在执行 f() 时依然有效。 "},{"title":"JavaScript 之手撕call、apply","date":"2021-12-29T06:04:47.000Z","url":"/2021/12/29/JavaScript-%E4%B9%8B%E6%89%8B%E6%92%95call%E3%80%81apply/","tags":[["call、apply","/tags/call%E3%80%81apply/"]],"categories":[["undefined",""]],"content":"前言call/apply 的核心理念就是借用方法。call/apply 做的是这样的事， A 对象上实现了一个方法， B 对象由于一些需求，也需要调用同样的方法，最好的方法肯定是 B 直接去调用 A 对象的方法，自身无需扩展。 基本介绍语法： 参数 thisArg(可选)： fn 函数的 this 指向 thisArg thisArg 传入 null, undefined ；非严格模式下： fn 函数 this -&gt; window ；严格模式下： this -&gt; undefined 值为原始值(数字，字符串，布尔值)时， this 指向包装类 arg1,arg2 (可选)：传给 fn 的参数 apply 传递的第二个参数为数组 作用改变 this 指向 常见用法 判断数据类型： typeof 方法只返回七种值： string、number、boolean、undefined、object、function、symbol 。所以使用 typeof 是无法区分 array 和普通对象的。 Object.prototype.toString 方法可以判断所有的类型，但 Array、String 等都重写了该方法，因此就需要借助 call/apply 来实现 类数组调用数组的方法 类数组定义① 拥有 length 属性，其他属性(索引)为非负整数(对象中的索引会被当做字符串来处理)；② 不具有数组所具有的方法；JavaScript 中常见的类数组有 arguments 对象和 DOM 方法的返回结果。比如 doucment.getElementsByTagName() 。 ES6 未发布之前，没有 Array.from 方法可以将类数组转为数组，采用 Array.prototype.slice.call(arguments) 或者 [].slice.call(arguments) 将类数组转化为数组。 apply 求数组的最大值与最小值 JavaScript 中没有给数组提供类似 max 和 min 函数，只提供了 Math.max/min ，用于求多个数的最值，所以可以借助 apply 方法，直接传递数组给 Math.max/min 手撕 call初步模拟首先先来看一个例子，分析一下 call 函数的执行过程： 可见 call 函数调用大致执行了两步： call 改变了 this 指向， this -&gt; obj fun 函数执行 那该如何模拟上面的效果呢？如果在 obj 上定义函数 fun，之后 obj.fun 执行是不是就达成了上述的效果。所以 call 的模拟步骤大约为： 将函数 fn 设为 thisArg 的对象的方法 执行 thisArg.fn 删除该函数 完善上面实现了 call 的最初版本代码，还有几个地方有待解决： 未传入 thisArg 参数： 当未传入 thisArg 或传入 null 时，函数的 this -&gt; window 传入 arg1，arg2 等参数：ES6 可以通过 rest 参数来实现， ES6 以前可以通过 arguments 来实现 eavl() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。array 在与字符串相加时，会调用 array.toString 方法 ([1,2,3].toString() // “1,2,3”) 函数可以拥有返回值举个例子： 不过很好解决，因此只需将 eval 执行之后的结果返回即可。接着我们来看一下完整版的代码： 如果使用 ES6 语法进行模拟代码会简单很多 手撕 applyapply 的代码实现与 call 类似，这里直接给代码。 "},{"title":"JavaScript 之手撕 new","date":"2021-12-25T07:00:37.000Z","url":"/2021/12/25/JavaScript-%E4%B9%8B%E6%89%8B%E6%92%95-new/","tags":[["new","/tags/new/"]],"categories":[["undefined",""]],"content":"前言什么是 new 呢？ new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。 光看定义还是有几分晦涩的，直接看一个具体的例子，来了解一下 JavaScript 中的 new 实现的功能。 举个例子 通过上面这个例子，我们可以发现 xiaobao 可以： 访问到构造函数 Thin_User 中的属性 访问到 Thin_User.prototype 中的属性 描述的更直白一点， new 做了这几件事： 创建了一个空对象，对象的 __ proto __ -&gt; Thin_User.prototype 执行构造函数，并将 this 指向新对象 返回新对象 补充说明由于 new 是关键字，我们无法像模拟数组高阶方法一样覆盖，因此我们写一个函数 createObject ，来模拟 new 的效果。使用具体如下： 初步模拟根据上面的分析，**createObject** 编写大致步骤为： 创建了一个新对象 obj 设置 obj.__ proto __ -&gt; constructor.prototype (但 JavaScript 不推荐直接修改 __ proto__ 属性，提供了 setPrototypeOf 方法来专门修改原型) 使用 constructor.call/apply(obj,…) ,将属性添加到 obj 上 返回 obj 返回值效果众所周知，函数是有返回值的，那构造函数如果有返回值，最终执行 new 后返回的结果是什么样的？ 返回值为基本类型假设构造函数返回值为一个基本类型，我们来看一下最后的返回结果： 最终的返回结果好像没有受到任何干扰，难道构造函数不会对返回值进行处理吗？ 不急，我们来接着测试一下返回值为对象的情况。 当执行 eatToMuch 时，控制台直接报错，没有当前函数，所以答应了 xiaobao 对象： 发现 xiaobao 对象的 age 发生了改变，而且增加了 fat 属性，正好与构造函数的返回值一样。看完这两个例子，基本可以理清构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象。 最终模拟"},{"title":"JavaScript 预编译","date":"2021-12-20T06:09:53.000Z","url":"/2021/12/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","tags":[["JavaScript","/tags/JavaScript/"],["预编译","/tags/%E9%A2%84%E7%BC%96%E8%AF%91/"]],"categories":[["undefined",""]],"content":"JavaScript 从预编译到执行的过程，大致可以分为四步： 词法分析 语法分析：检查代码是否存在错误，若有错误，引擎会抛出语法错误。同时会构建一颗抽象语法树(AST) 预编译 解释执行 预编译 JavaScript 是解释性语言，也就是说，编译一行，执行一行，但是 JS 并非上来就进入编译环节，它在编译之前存在预编译过程。 JS 中预编译一般有两种：全局的预编译和函数的预编译，分别发生在 script 内代码执行前和函数执行前。 函数预编译 首先来看一个例子： 就以上例子中 a 为例，有形参 a ，变量 a ，函数 a ，那 test 函数执行的时候，此时的 a 到底是什么呢？ 输出结果： 要想弄明白最终的输出结果，就不得不好好学习一下预编译的详细过程。 在预编译学习中，经常听到的一句话：函数声明整体提升，变量声明提升。 这句话可以解决大多数场景下的预编译面试题，但光凭这句话是无法吃透预编译的，因此接下来我们来一起捋一下函数预编译的详细流程。 函数预编译四步曲 预编译开始，会建立 AO(Activation Object) 对象 找形参和变量声明，使其作为 AO 的属性名，值赋予 undefined 实参和形参相统一(将实参值赋值为给形参) 找函数声明，函数名作为 AO 属性名，值赋予函数体 案例分析学习了函数的预编译过程，就可以回头细细的品味一下上面的案例： 先建立 AO ，并找形参和变量声明，值赋予 undefined 形参实参相统一 找函数声明，值赋予函数体 预编译过程结束，挨着分析一下 console 的打印结果： 全局预编译 全局中不存在形参和实参，所以全局预编译只需处理变量声明和函数声明。 全局预编译 生成 GO(Global Object) 找变量声明，由于全局变量默认挂载在 window 之上，若 window 当前已存在当前属性，忽略当前操作，若没有，变量作为属性名，值赋予 undefined。 找函数声明，函数与变量类似，先去 window 上查看，不存在，函数作为函数名，值作为函数体。 案例分析将函数预编译案例稍微修改，如下： 生成 GO ，变量提升，函数提升，得到 GO 如下： 因此第一个 a 的值为 undefined ，随后 a 赋值为 1 ，所以第二个 a 的值为 1。 输出结果： test 中定义了变量 a，因此打印的 a 为 自身 AO 中的值。如果 test 中没有定义 a，就会沿着作用域链，到 GO 中 查找 a。 "}]