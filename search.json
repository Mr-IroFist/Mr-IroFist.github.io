[{"title":"JavaScript 之手撕call、apply","date":"2021-12-29T06:04:47.000Z","url":"/2021/12/29/JavaScript-%E4%B9%8B%E6%89%8B%E6%92%95call%E3%80%81apply/","tags":[["call、apply","/tags/call%E3%80%81apply/"]],"categories":[["undefined",""]],"content":"前言call/apply 的核心理念就是借用方法。call/apply 做的是这样的事，**A** 对象上实现了一个方法， B 对象由于一些需求，也需要调用同样的方法，最好的方法肯定是 B 直接去调用 A 对象的方法，自身无需扩展。 基本介绍语法： 参数 thisArg(可选)： fn 函数的 this 指向 thisArg thisArg 传入 null, undefined ；非严格模式下：**fn** 函数 this -&gt; window ；严格模式下：**this -&gt; undefined** 值为原始值(数字，字符串，布尔值)时，**this** 指向包装类 arg1,arg2 (可选)：传给 fn 的参数 apply 传递的第二个参数为数组 作用改变 this 指向 常见用法 判断数据类型：**typeof** 方法只返回七种值：**string、number、boolean、undefined、object、function、symbol** 。所以使用 typeof 是无法区分 array 和普通对象的。 Object.prototype.toString 方法可以判断所有的类型，但 Array、String 等都重写了该方法，因此就需要借助 call/apply 来实现 类数组调用数组的方法 类数组定义① 拥有 length 属性，其他属性(索引)为非负整数(对象中的索引会被当做字符串来处理)；② 不具有数组所具有的方法；JavaScript 中常见的类数组有 arguments 对象和 DOM 方法的返回结果。比如 doucment.getElementsByTagName() 。 ES6 未发布之前，没有 Array.from 方法可以将类数组转为数组，采用 Array.prototype.slice.call(arguments) 或者 [].slice.call(arguments) 将类数组转化为数组。 apply 求数组的最大值与最小值 JavaScript 中没有给数组提供类似 max 和 min 函数，只提供了 Math.max/min ，用于求多个数的最值，所以可以借助 apply 方法，直接传递数组给 Math.max/min 手撕 call初步模拟首先先来看一个例子，分析一下 call 函数的执行过程： 可见 call 函数调用大致执行了两步： call 改变了 this 指向， this -&gt; obj fun 函数执行 那该如何模拟上面的效果呢？如果在 obj 上定义函数 fun，之后 obj.fun 执行是不是就达成了上述的效果。所以 call 的模拟步骤大约为： 将函数 fn 设为 thisArg 的对象的方法 执行 thisArg.fn 删除该函数 完善上面实现了 call 的最初版本代码，还有几个地方有待解决： 未传入 thisArg 参数： 当未传入 thisArg 或传入 null 时，函数的 this -&gt; window 传入 arg1，arg2 等参数：ES6 可以通过 rest 参数来实现， ES6 以前可以通过 arguments 来实现 eavl() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。array 在与字符串相加时，会调用 array.toString 方法 ([1,2,3].toString() // “1,2,3”) 函数可以拥有返回值举个例子： 不过很好解决，因此只需将 eval 执行之后的结果返回即可。接着我们来看一下完整版的代码： 如果使用 ES6 语法进行模拟代码会简单很多 手撕 applyapply 的代码实现与 call 类似，这里直接给代码。 "},{"title":"JavaScript 之手撕 new","date":"2021-12-25T07:00:37.000Z","url":"/2021/12/25/JavaScript-%E4%B9%8B%E6%89%8B%E6%92%95-new/","tags":[["new","/tags/new/"]],"categories":[["undefined",""]],"content":"前言什么是 new 呢？ new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。 光看定义还是有几分晦涩的，直接看一个具体的例子，来了解一下 JavaScript 中的 new 实现的功能。 举个例子 通过上面这个例子，我们可以发现 xiaobao 可以： 访问到构造函数 Thin_User 中的属性 访问到 Thin_User.prototype 中的属性 描述的更直白一点， new 做了这几件事： 创建了一个空对象，对象的 __ proto __ -&gt; Thin_User.prototype 执行构造函数，并将 this 指向新对象 返回新对象 补充说明由于 new 是关键字，我们无法像模拟数组高阶方法一样覆盖，因此我们写一个函数 createObject ，来模拟 new 的效果。使用具体如下： 初步模拟根据上面的分析，**createObject** 编写大致步骤为： 创建了一个新对象 obj 设置 obj.__ proto __ -&gt; constructor.prototype (但 JavaScript 不推荐直接修改 __ proto__ 属性，提供了 setPrototypeOf 方法来专门修改原型) 使用 constructor.call/apply(obj,…) ,将属性添加到 obj 上 返回 obj 返回值效果众所周知，函数是有返回值的，那构造函数如果有返回值，最终执行 new 后返回的结果是什么样的？ 返回值为基本类型假设构造函数返回值为一个基本类型，我们来看一下最后的返回结果： 最终的返回结果好像没有受到任何干扰，难道构造函数不会对返回值进行处理吗？ 不急，我们来接着测试一下返回值为对象的情况。 当执行 eatToMuch 时，控制台直接报错，没有当前函数，所以答应了 xiaobao 对象： 发现 xiaobao 对象的 age 发生了改变，而且增加了 fat 属性，正好与构造函数的返回值一样。看完这两个例子，基本可以理清构造函数有返回值的情况：当构造函数返回值为对象时，直接返回这个对象。 最终模拟"},{"title":"JavaScript 预编译","date":"2021-12-20T06:09:53.000Z","url":"/2021/12/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","tags":[["JavaScript","/tags/JavaScript/"],["预编译","/tags/%E9%A2%84%E7%BC%96%E8%AF%91/"]],"categories":[["undefined",""]],"content":"JavaScript 从预编译到执行的过程，大致可以分为四步： 词法分析 语法分析：检查代码是否存在错误，若有错误，引擎会抛出语法错误。同时会构建一颗抽象语法树(AST) 预编译 解释执行 预编译 JavaScript 是解释性语言，也就是说，编译一行，执行一行，但是 JS 并非上来就进入编译环节，它在编译之前存在预编译过程。 JS 中预编译一般有两种：全局的预编译和函数的预编译，分别发生在 script 内代码执行前和函数执行前。 函数预编译 首先来看一个例子： 就以上例子中 a 为例，有形参 a ，变量 a ，函数 a ，那 test 函数执行的时候，此时的 a 到底是什么呢？ 输出结果： 要想弄明白最终的输出结果，就不得不好好学习一下预编译的详细过程。 在预编译学习中，经常听到的一句话：函数声明整体提升，变量声明提升。 这句话可以解决大多数场景下的预编译面试题，但光凭这句话是无法吃透预编译的，因此接下来我们来一起捋一下函数预编译的详细流程。 函数预编译四步曲 预编译开始，会建立 AO(Activation Object) 对象 找形参和变量声明，使其作为 AO 的属性名，值赋予 undefined 实参和形参相统一(将实参值赋值为给形参) 找函数声明，函数名作为 AO 属性名，值赋予函数体 案例分析学习了函数的预编译过程，就可以回头细细的品味一下上面的案例： 先建立 AO ，并找形参和变量声明，值赋予 undefined 形参实参相统一 找函数声明，值赋予函数体 预编译过程结束，挨着分析一下 console 的打印结果： 全局预编译 全局中不存在形参和实参，所以全局预编译只需处理变量声明和函数声明。 全局预编译 生成 GO(Global Object) 找变量声明，由于全局变量默认挂载在 window 之上，若 window 当前已存在当前属性，忽略当前操作，若没有，变量作为属性名，值赋予 undefined。 找函数声明，函数与变量类似，先去 window 上查看，不存在，函数作为函数名，值作为函数体。 案例分析将函数预编译案例稍微修改，如下： 生成 GO ，变量提升，函数提升，得到 GO 如下： 因此第一个 a 的值为 undefined ，随后 a 赋值为 1 ，所以第二个 a 的值为 1。 输出结果： test 中定义了变量 a，因此打印的 a 为 自身 AO 中的值。如果 test 中没有定义 a，就会沿着作用域链，到 GO 中 查找 a。 "}]